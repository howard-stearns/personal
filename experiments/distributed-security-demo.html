<!DOCTYPE html>
<html style="font-family: sans-serif">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, viewport-fit=cover">
    <style>
      h1, h2 {text-align: center;}
      textarea {width: 100%;}
      p.result {overflow-x: hidden; white-space: nowrap; text-overflow: ellipsis;}
      input[name="spacer"] {visibility: hidden;}
      :root {--revealed:none; --signed:none; --encrypted:none; --persona:none; --adding:none; --recovery:none; }
      .reveal {display: var(--revealed);}
      .signed {display: var(--signed);}
      .encrypted {display: var(--encrypted);}
      .persona {display: var(--persona);}
      .adding {display: var(--adding);}
      .recovery {display: var(--recovery);}
      /* text toggle */
      .toggle input:checked + span:before { content: '\0021E7' }
      .toggle input:not(:checked) + span:before { content: '\002048' } /*'\002139'*/
      .toggle input { display: none; }
      .toggle { color: blue; font-weight: bold; }
    </style>
  </head>
  <body>
    <h1><a href="https://github.com/kilroy-code/distributed-security">Distributed Security</a></h1>
    <h2>Demo</h2>
    <h3>Part I. Cryptography Basics</h3>
    <p class="reveal result"><span style="color:blue;">&ShortDownArrow;</span> devices included in your persona</p>
    <p class="result">
      <input type="checkbox" class="reveal" checked/>
      <label><input type="radio" name="use" value="thisDevice" checked /> This device tag:</label>
      <span id="thisDevice" contenteditable>(generating...)</span>
    </p>
    <p class="result">
      <input type="checkbox" class="reveal"/>
      <label><input type="radio" name="use" value="thatDevice"/> Another computer tag:</label>
      <span id="thatDevice">(generating...)</span>
    </p>    
    <textarea id="message">Your message here.</textarea>

    <hr/>
    <p class="result">1. <button id="sign" disabled>sign</button> signature: <span id="signature" contenteditable></span></p>
    <p class="result"> <label class="toggle"><input type="checkbox" onclick="toggle('--signed')"/><span/></label> verified: <span id="verified"></span> </p>
    <p class="signed">You can only sign with a tag you have access to on your computer. But <i>anyone can then verify</i> a given tag/message/signature combination.</p>
    <ul class="signed">
      <li>Any change to the message, signature, or tag will cause verification to fail. Try it! (You can always <button onclick="navigation.reload()">reload</button>.)</li>
      <li>You cannot sign with a tag you don't have. Try re-signing with the tag from another computer. (Click "Another computer tag" and then "sign".)</li>
    </ul>
    <p class="signed"><b>Why it matters:</b> Without any login or central authority, users can sign a message that can be verified by anyone as coming from that tag and only from that tag. The message might be:</p>
    <ul class="signed">
      <li>a specified post</li>
      <li>a request to store or modify something with specified new content</li>
      <li>a specified transaction</li>
      <li>an attestation as to the truth, existence, or conformance of some specified fact</li>
    </ul>

    <hr/>
    <p class="result">2. <button id="encrypt" disabled>encrypt</button> encrypted: <span id="encrypted" contenteditable></span></p>
    <p class="result"> <label class="toggle"><input type="checkbox" onclick="toggle('--encrypted')"/><span/></label> decrypted: <span id="decrypted"></span></p>
    <p class="encrypted"><i>Anyone can encrypt</i> a message so that only someone with the specified tag can then read it. (This is the opposite of signing as to who takes the first step.)</p>
    <ul class="encrypted">
      <li>A change to the enryption or tag will cause the decryption to fail. Try it!</li>
      <li>You <i>can</i> encrypt for a tag you don't have. Try re-encrypting with the tag from another computer. The encryption will work, but ony someone with the specified tag can decrypt it.</li>
    </ul>
    <p class="encrypted"><b>Why it matters:</b> Without any login or centralized access control permissions, users can encrypt content that can be sent in the open and stored anywhere, but only the intended party can read it. (Not even the makers of the software, the site storing the data, or someone who legally or illegally gains access to the stored data.)</p>

    <hr/>
    <hr/>    
    <h3>Part II. Key Management</h3>
    <p>1. <button id="persona" disabled>create persona from this device</button></p>
    <p class="result">
      <label class="toggle"><input type="checkbox" onclick="toggle('--persona')"/><span/></label> 
      <label><input type="radio" name="use" value="yourPersona" /> Your persona:</label> <span id="yourPersona" contenteditable></span>
    </p>
    <p class="persona">Behind each tag is a set of cryptographic keys that drive the math. If you lose the keys, you lose the ability to sign or decrypt, and if someone else gets your keys, they could sign or decrypt your stuff.</p>
    <p class="persona">It would be neither convenient nor secure to have to copy device keys from one computer to another. Instead, we create another set of keys to represent a <i>persona</i>:</p>
    <ul class="persona">
      <li>Each set of device keys is securely kept only in a vault on the computer on which they are generated, and they cannot be copied anywhere.</li>
      <li>The persona keys are <i>encrypted</i> by the device keys and <i>stored in the cloud</i>, where they are available to any of your devices, but to no one else.</li>
      <li>The only thing that the device tags are used for is to encrypt and decrypt the persona keys that they have been added to. Applications use only the persona tags. (In this demo, you can switch back an forth between the various tags shown, and show that they all work the same way for cryptography.)</li>
      <li>An application might make just one persona for you that is different than personas for other applications, or several applications could use the same opt-in persona, or applications could invite you to make multiple personas for different purposes. In this demo, you can create and destroy one persona at a time. Try out the various operations using the new or destroyed persona tag.</li>
    </ul>
    <p class="persona"><b>Why it matters:</b> A persona - or multiple personas -- allows you to have an identity that you can use across all your devices.</p>
    <hr/>
    <p>
      <label class="toggle"><input type="checkbox" onclick="toggle('--adding')"/><span/></label> 
      2. If you have created a persona, you can use the checkboxes at the top to add or remove devices from your persona. Remember that you can "forget persona" and create a new one.
    </p>
    <p class="adding">If the device tag on your browser is part of your persona, then you can add or remove other devices. E.g., you (nor someone else) can change the devices for <i>your</i> persona without already being authorized.</p>
    <p class="adding"><b>Why it matters:</b> Each device acts as a backup that allows you to add/remove other devices, so there is no need for <i>anyone</i> to have a custodial copy of your unencrypted keys.</p>
    <hr/>
    <p>
      <label class="toggle"><input type="checkbox" onclick="toggle('--recovery')"/><span/></label> 
      3. <button id="recovery" disabled>TBD: add recovery questions</button>
    </p>
    <p class="recovery">This section isn't implemented yet, but will allow the user to add or remove security questions to the persona, which act like virtual devices that can be added without adding a physical device vault. Answering a question (or pair of questions, or tripple of questions, ...) unlocks the persona, so that further changes can be made (such as adding a new device or removing one that you no longer have access to).</p>
    <p class="recovery"><b>Why it matters:</b> Even if you lose access to all your devices, the security questions can be used to add a new device (or to have the cloud permanently forget your persona).</p>
    <hr/>
    <p>
      4. Not shown in this demo: Just as you can create a persona and add/remove device tags for it, you can create a <i>team</i> and add/remove persona tags for it.
    </p>
    <p><b>Why it matters:</b> This allows arbitrary groups of individuals to act as a single entity - signing a message, or decrypting a message that was encrypted for the whole team (and no one else) to read.</p>
      

    <script>
      var demoSecret = 'thisDevice'; // What should be returned by Security.getUserDeviceSecret in this app.
      function setGood(element) { // Return a function to set an element with a good result.
	return function (text) {
	  element.textContent = text;
	  element.style.color = 'darkgreen';
	}
      }
      function setBad(element) { // Return a function to set an element with a bad result.
	return function (errorOrText) {
	  element.textContent =  errorOrText?.message || errorOrText;
	  element.style.color = 'red';
	}
      }	
      async function setText(element, promisedText, errorTextOverride = '') { // Set element text from a promise that may resolve or reject.
	return promisedText.then(setGood(element), setBad(element, errorTextOverride));
      }
      async function displayTag(name, producer) { // generate if ncessary and persist, and set display
	let tag = localStorage.getItem(name),
	    element = document.getElementById(name),
	    setDisplay = setGood(element);
	if (!tag) {
	  tag = await producer();
	  localStorage.setItem(name, tag);
	}
        setDisplay(tag);
	return tag;
      }
      function selectedTagElement() { // Return the tag display that is selected by radio buttons.
        let checkedRadio = document.querySelector('input[name = "use"]:checked');
	return document.getElementById(checkedRadio.value);
      }
      function getTag() { return selectedTagElement().textContent; }  // Return selected tag
      // Muck with a CSS property to reveal or hide extra info. (Too distracting to show when starting out.)
      function muck(property, on = true) { document.documentElement.style.setProperty(property, on ? 'inline-block' : 'none'); }
      function toggle(property) { muck(property, event.target.checked); }
    </script>

    <script type="module">
      import Security from "https://kilroy-code.github.io/distributed-security/index.mjs";
      //import Security from "http://localhost:3000/@kilroy-code/distributed-security/index.mjs";
      import Cloud from "./cloud.mjs"; // A simple browser-local "cloud" for this demo.

      // Applications must give Security an implementation of cloud storage and a secret.
      Security.Storage = Cloud;
      // Answer any string that is always the same for the same individual user on this device.
      // Used in encrypting device keys within the vault. 
      // For security, it should be different for different users and for different devices.
      Security.getUserDeviceSecret = () => demoSecret;

      await Security.ready;            // And wait for Security to initialize.
      window.Security = Security; // FIXME remove

      async function getCheckedTag(element = selectedTagElement()) { // Return the specified tag.
	// And for demo purposes, color it to show whether it is valid (e.g., after editing).
	let tag = element.textContent;
	Security.sign(tag, "dummy message that will fail to sign if we don't have key")
          .then(() => setGood(element)(tag),
		() => setBad(element)(tag));
	return tag;
      }

      await displayTag('thisDevice', function () { return Security.create(); })
      demoSecret = 'thatDevice'; // Emulate another device by changing the secret while creating another tag...
      await displayTag('thatDevice', function () { return Security.create(); })
      demoSecret = 'thisDevice'; // ... and change it back so the temporary value is no longer accessible to us.
      await getCheckedTag(thatDevice); // Show by side-effect that we cannot use it.
      [sign, encrypt, persona].forEach(function (button) { button.disabled = false; });

      function maybeRedo() { 
	if (verified.textContent) signature.oninput();
	if (encrypted.textContent) encrypted.oninput();
      }
      thisDevice.oninput = yourPersona.oninput = () => {
	getCheckedTag();
	maybeRedo();
      };
      document.querySelectorAll('input[name = "use"').forEach(function (radio) { radio.onchange = maybeRedo; });
      message.oninput = function ()  {
	if (verified.textContent) signature.oninput();
      };
      sign.onclick = async function () { // Sign the message, verify the signature, and show both results.
	await setText(signature, Security.sign(getTag(), message.value));
        await signature.oninput();
      };
      signature.oninput = async function () { // Verify the current contents of signature against message.
	await setText(verified, Security.verify(getTag(), signature.textContent, message.value));
      }
      encrypt.onclick = async function () { // Encrypt the message, decrypt it, and show both results.
	await setText(encrypted, Security.encrypt(getTag(), message.value));
        await encrypted.oninput();
      };
      encrypted.oninput = async function () { // Decrypt the current contents of encrypted.
	await setText(decrypted, Security.decrypt(getTag(), encrypted.textContent));
      };
      async function createPersona() {
        yourPersona.textContent = "(generating...)";
	await setText(yourPersona, Security.create(thisDevice.textContent));
	localStorage.setItem('yourPersona', yourPersona.textContent);
	persona.onclick = destroyPersona;
        persona.textContent = "forget persona";
        muck('--revealed');
	document.querySelector('input[value = "yourPersona"]').checked = true;
      }
      async function destroyPersona() {
	let recreate = false;
	await Security.destroy(yourPersona.textContent).catch(async error => {
	  alert(error.message + ' but we will create a new persona.');
	  recreate = true;
	});
	await getCheckedTag(yourPersona);
	localStorage.removeItem('yourPersona');
	persona.onclick = createPersona;
	persona.textContent = "create persona from this device";
	if (recreate) await createPersona();
      }
      let personaTag = localStorage.getItem('yourPersona');
      if (personaTag) {
	setGood(yourPersona)(personaTag);
	persona.onclick = destroyPersona;
	persona.textContent = "forget persona";
        document.querySelector('input[value = "yourPersona"]').checked = true;
        muck('--revealed');
      } else {
	persona.onclick = createPersona;
      }
      document.querySelectorAll('input[type="checkbox"].reveal').forEach(checkbox => {
	checkbox.onclick = async event => {
	  let deviceLabel = checkbox.parentElement.querySelector('input[type="radio"]').value,
	      deviceTag = document.getElementById(deviceLabel).textContent,
	      options = {},
	      option = checkbox.checked ? 'add' : 'remove',
	      personaTag = yourPersona.textContent;
	  options[option] = deviceTag;
	  await Security.changeMembership(personaTag, options).catch(error => {
	    alert(error.message);
	    checkbox.checked = !checkbox.checked;
	  });
	};
      });
    </script>
  </body>
</html>
