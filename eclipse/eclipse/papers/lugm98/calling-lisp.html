<HTML>
<HEAD>
<TITLE>Lisp/C Integration in Eclipse: Using Lisp from C</TITLE>
<meta name="description" content="Using Lisp from C">
<meta name="keywords" content="lisp, call, C, direct, funcall,
example, eval, load, keyword">  
<meta name="date" content="9/1/97">
<meta name="author" content="Howard Stearns">
<meta name="copyright" content="Elwood Corp.">
</HEAD>

<BODY bgcolor="#FFFFFF">

<A HREF="lisp-c.html">[Paper Contents]</A> 
<A HREF="core.html">[Previous]</A> 
<A HREF="calling-c.html">[Next]</A> 
<A HREF="http://www.elwood.com/eclipse-info">[Eclipse Home Page]</A>

<HR>

<a name="c-calls-lisp"><h2>3: Using Lisp from C</h2></a>

The functions created by Eclipse <code>COMPILE-FILE</code> may be called by C
programs directly, or through <code>FUNCALL</code>.

<ul>
<p><li> These two different mechanisms may be used by any C (or
C-compatible) caller; regardless of whether the caller is hand-written
code, or code that is itself generated by Eclipse <code>COMPILE-FILE</code>.

<p><li> The two mechanisms are available for calling any ``Lisp
function,'' by which we mean any function that follows the conventions
used by Eclipse. Such functions can be produced by Eclipse
<code>COMPILE-FILE</code> from Lisp source code or can be written by
hand. Since Eclipse provides all Common Lisp functions through its
<code>COMPILE-FILE</code> generated library, any Common Lisp function
can be called from C using either approach.<a
href="references.html#f5"><b>5</b></a>
</ul>

<p>
The examples given here assume a C file is produced by Eclipse using
<code>(COMPILE-FILE "my-file.lisp" :OUTPUT-FILE "my-file.c")</code> and that
``my-file.lisp'' contains a function <code>USER:MY-FUNCTION</code>, defined as:

<pre>
   (DEFUN MY-FUNCTION (A B)
     (LIST A B))
</pre>

<p>
This section discusses direct calls and the use of <code>FUNCALL</code>, and gives
a listing of ``my-file.c.'' The section ends with some notes on how C
programs use such Lisp utilities as <code>EVAL</code>, <code>LOAD</code>, and the passing of
<code>clObject</code>s such as keywords, fixnums, and so on.

<a name="direct"><h3>3.1: Direct Calls</h3></a>

In Lisp, one can call <code>MY-FUNCTION</code> directly like this:

<pre>
   (SETQ X (MY-FUNCTION Y Z))
</pre>

<p>
The Eclipse-generated C function <code>usrMyFunction()</code> can be directly
called by other C functions as follows:

<pre>
   clObject usrMyFunction(clProto);
   ...
   { clObject x, y, z;
     ...
     clSetq(x, usrMyFunction(y, z, clEOA));
     ... }
</pre>

<p>
This code declares the C function to return an
<code>clObject</code>. <code>clProto</code> is a macro defined in
``eclipse.h'' that indicates that a variable number of
<code>clObject</code> arguments are accepted. (Eclipse conditionally
defines <code>clProto</code> for different compilers to correctly use
prototypes, varargs/stdargs, and so forth.)

<p>
The C function called in this example takes the same arguments as the
original Lisp function did, with one additional argument,
<code>clEOA</code>, used by the function for argument parsing. (See <a
href="core.html#functions">Section 2.2.2</a>.)

<p>
The use of the Eclipse-defined macro <code>clSetq(x,
<i>call</i>)</code>, rather than <code>x = <i>call</i></code>, gives a
more Lisp-like syntax to the C code, and allows cleaner linting. (See
<a href="core.html#objects">Section 2.2.1</a>.)

<p>
This is the easiest, most idiomatic C way to call Lisp functions. Like
all C function calls, the called code must be defined in C (or a
compatible language), compiled, and linked before the application is
run. This technique can only be used when the definition of
<code>MY-FUNCTION</code> will not change at run time. When hand-coding C that uses
direct calls, the programmer must be certain that these conditions are
met, just as for any other direct C call.

<p>
Eclipse <code>COMPILE-FILE</code> can automatically use this direct function call
technique in code it generates only when:

<ul>
<p><li> The definition can be assumed to not change, such as for system
functions, functions declared to not change, and so on.

<p><li> The system can assume that such a named C function exists, such as
when it already exists in the compilation environment, appears as a
<code>DEFUN</code> or <code>DEFGENERIC</code> within the current compilation environment, or is
otherwise declared to exist.

<p><li> There is no possibility of creating additional closures over the
same code. This is true for all global functions, and is not true for
flet/lables that themselves are referenced from dynamic closures.
</ul>

<p>
(In fact, the currently released compiler uses the direct approach
only for ordinary system function calls.)

<a name="funcall"><h3>3.2: Funcall</h3></a>

In Lisp, one can indirectly ``funcall'' <code>MY-FUNCTION</code> through it's symbol:

<pre>
   (SETQ X (FUNCALL 'MY-FUNCTION Y Z)
</pre>

<p>
To do this in C, we use three functions that Eclipse makes available
for direct use by C programmers:
<code>clCharpSimpleBaseString()</code>, <code>clIntern()</code>, and
<code>clFuncall()</code>. The latter two are simply direct calls to
Lisp functions, as described in <a
href="calling-lisp.html#direct">Section
3.1</a>. <code>clCharpSimpleBaseString()</code> is not a ``Lisp
function'' at all, but rather a constructor that creates a Lisp string
<code>clObject</code> from a C char pointer.

The C call looks like:

<pre>
   clObject usrMY_FUNCTION, my_function_string, x, y, z; 
   clSetq(my_function_string, clCharpSimpleBaseString("MY-FUNCTION"));
   clSetq(usrMY_FUNCTION, clIntern(my_function_string, clEOA)); 
   ...
   clSetq(x, clFuncall(usrMY_FUNCTION, y, z, clEOA));
</pre>

<p>
Of course, <code>usrMY_FUNCTION</code> can be a global or static variable that is
initialized just once, and used in each funcall.

<p>
There is no need to declare <code>usrMyFunction()</code> in C when using this
<code>FUNCALL</code> approach. In fact, <code>usrMyFunction()</code> does not even have to be
defined in C. For example, it could be defined as an interpreted
function at run time. It does not matter if the definition of
<code>MY-FUNCTION</code> changes at run time; funcallers will see the new
definition.

<a name="example"><h3>3.3: Example Of Generated Code</h3></a>

There are several parts to our example Eclipse-generated ``my-file.c.''

<ul>
<p><li> First ``eclipse.h'' is included. The code then declares functions and
static ``variables'' that are used to represent compile-file literals.

<p><li> The definition of <code>usrMyFunction()</code> itself begins with some argument
parsing code. <code>clVdecl()</code>, <code>clBeginParse()</code>, <code>clEndParse()</code>, <code>_clVp()</code>,
<code>clVpop()</code>, and <code>clVargs()</code> are all macros dealing with variable argument
parsing. <code>clMissingArgs()</code> and <code>clExtraArgs()</code> are ordinary Lisp
functions. The returned value is a direct call to the Lisp function
<code>clList()</code>.

<p><li> The function <code>usrMyFile()</code> is the Eclipse-generated
initialization function for the file. (See <a
href="core.html#initialization">Section 2.4.2</a>.) In keeping with
ANSI requirements for <code>LOAD</code>, it temporarily binds
<code>*PACKAGE*</code>, <code>*READTABLE*</code>,
<code>*LOAD-TRUENAME*</code> and <code>*LOAD-PATHNAME*</code>. Within
this context, it first creates the symbols and fixnums needed, and
then sets the <code>SYMBOL-FUNCTION</code> for the symbol
<code>MY-FUNCTION</code> to a closure that it creates.  </ul>

<a name="listing"><h4>Listing of Eclipse-generated C code ``my-file.c'':</h4></a>

<pre>
   #include &lt;eclipse.h&gt;

   clObject clCharpSimpleBaseString __P((clCharp)), clExtraArgs(clProto),
     clIntern(clProto), clList(clProto), clMissingArgs(clProto), clPkg(clProto);

   static clObject I_1, I_2, PKG_USER, STR_MY_FUNCTION__0, STR_USER__1, usrMY_FUNCTION;

   clObject usrMyFunction clVdecl(_ap)
   { clObject a, b;
     { clBeginParse(_ap); 
       clSetq(a, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
       clSetq(b, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA))); 
     if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
     clEndParse(_ap); }
     { clObject L_1, L_0; 
       clSetq(L_0, a); 
       clSetq(L_1, b); 
     return(clList(L_0, L_1, clEOA)); } }

   void usrMyFile __P((void))
   { clDbind(clstarPACKAGEstar);
     clDbind(clstarREADTABLEstar); 
     clDbind(clstarLOAD_TRUENAMEstar); 
     clDbind(clstarLOAD_PATHNAMEstar); 
     clSetq(STR_MY_FUNCTION__0, clCharpSimpleBaseString("MY-FUNCTION")); 
     clSetq(STR_USER__1, clCharpSimpleBaseString("USER"));
     clSetq(PKG_USER, clPkg(STR_USER__1, clEOA));
     clSetq(usrMY_FUNCTION, clIntern(STR_MY_FUNCTION__0, PKG_USER, clEOA));
     clSetq(I_1, clIntFixnum(1)); 
     clSetq(I_2, clIntFixnum(2));

     clSetSymbolFunctionValue(usrMY_FUNCTION,
			      clMakeClosure(0,
					    usrMyFunction,
					    clNULL_HOOK));
     (void) usrMY_FUNCTION;
     clUnwind(4); }
</pre>

<p>
The example shown is the actual code generated by the released Eclipse
1.1 compiler, presented without editing or formatting. Current
compiler development is aimed at producing the following changes:

<ul>
<p><li> Provide simpler argument parsing, including the ability for users to
declare that argument checking code should not be generated.

<p><li> Provide better temporary variable elimination. The temporary
variables <code>L_0</code> and <code>L_1</code> are introduced in
<code>usrMyFunction()</code> to guarantee correct left-to-right
evaluation of the arguments to <code>clList()</code>, because C does
not define the order of evaluation of arguments to functions. In this
case, they are not necessary and could have been eliminated by the
compiler.<a href="references.html#f6"><b>6</b></a>

<p><li> Create some literal data as C ``compile-time'' constants rather
than during execution of the <code>usrMyFile()</code> initialization
function. For example, <code>STR_MY_FUNCTION_0</code>,
<code>STR_USER__1</code>, <code>I_1</code>, and <code>I_2</code> and
the closure <code>clObject</code> could all be defined in this way.
</ul>

<a name="other-calls"><h3>3.5: Other Lisp Utilities and Their Effect on Calling Lisp Functions</h3></a>

The Lisp functions <code>EVAL</code> and <code>LOAD</code>, and the
<code>&KEY</code> named argument facility introduce other
possibilities in calling Lisp functions from C code.

<a name="eval"><h4>3.5.1: Eval</h4></a>

The function <code>EVAL</code> executes (e.g., interprets) arbitrary Lisp code,
including function call expressions. The argument to <code>EVAL</code> is a Lisp
expression; such as a number, a symbol, or a list beginning with a
symbol that names an operator.

<p>
Like most Lisp implementations, Eclipse provides an <code>EVAL</code>
function which interprets arbitrary Lisp code represented as
s-expression data.<a href="references.html#f7"><b>7</b></a> The
Eclipse implementation of this function can create arbitrary
interpreted closures at run time. Interpreted and compiled code can
call each other, use each other's cleanups and catch tags, and so
forth.

<p>
As with <code>FUNCALL</code>, Eclipse makes <code>EVAL</code> available for direct use by C
programmers as <code>clEval()</code>. Of course, it is necessary to give <code>clEval()</code>
an <code>clObject</code> as its argument.

<p>
For example, <code>MY-FUNCTION</code> could also be called from C as:

<pre>
   clSetq(x, clEval(clList(usrMY_FUNCTION, y, z, clEOA), 
		    clEOA));
</pre>

<p>
Note the use of <code>clList()</code> and the symbol <code>usrMY_FUNCTION</code> to create the
argument to <code>clEval</code>. Compare this with the <code>FUNCALL</code> version given above:

<pre>
   clSetq(x, clFuncall(usrMY_FUNCTION, y, z, clEOA));
</pre>

<a name="load"><h4>3.5.2: Load</h4></a>

The function <code>clLoad()</code> is also provided in the development
library. Alas, as currently implemented by Eclipse, this function
cannot be used to load compiled machine code (e.g., <code>.o</code> or <code>.obj</code> files)
into a running application.

<p>
In general, the C language and its implementations do not provide any
portable and easy way to load compiled machine code into a running
application. Outside of Eclipse, there are ways to do this on specific
platforms, and Eclipse users are free to utilize them. The Eclipse
system behavior with respect to such techniques is just like that of
any other C library, and Eclipse makes no special arrangements to
automatically update <code>SYMBOL-FUNCTION</code> values based on newly loaded
machine code.

<a name="passing-data"><h4>3.5.3: Passing Lisp Data</h4></a>

The preceding examples show <code>clObject</code>s being passed to and
returned from Lisp functions. No ``Lisp function'' accepts C data of
other types such as <code>int</code>, <code>enum</code>,
<code>double</code>, and so forth. Instead, it is necessary for the
caller to create <code>clObject</code>s using other Lisp functions,
such as <code>clIntern()</code>, or constructors provided in
``eclipse.h,'' such as <code>clCharpSimpleBaseString()</code> or
<code>clIntFixnum()</code>. Examples in ``my-function.c'' include the
use of <code>usrMY_FUNCTION</code> and <code>I_1</code>.

<p>
Named (i.e., <code>&KEY</code>) arguments are used just as they are in Lisp: the
``names'' are ordinary symbol arguments. Suppose <code>MY-FUNCTION</code> had been
defined as:

<pre>
   (DEFUN MY-FUNCTION (A &KEY B) (LIST A B))
</pre>

<p>
In Lisp, a direct call might look like:

<pre>
   (MY-FUNCTION X)
</pre>
or
<pre>
   (MY-FUNCTION X :B Y)
</pre>

<p>
The corresponding direct C calls are:

<pre>
   usrMyFunction(x, clEOA)
</pre>
and
<pre>
   usrMyFunction(x, keyB, y, clEOA)
</pre>

<p>
Here <code>keyB</code> is an <code>clObject</code> that might have been defined similarly to
<code>usrMY_FUNCTION</code> in ``my-function.c'':

<pre>
   clObject clMakeKeyword(clProto); 
   clObject keyB, b_string; 
   ...
   clSetq(b_string, clCharpSimpleBaseString("B"));
   clSetq(keyB, clMakeKeyword(b_string, clEOA));
</pre>

<HR>

<A HREF="lisp-c.html">[Paper Contents]</A> 
<A HREF="core.html">[Previous]</A> 
<A HREF="calling-c.html">[Next]</A> 
<A HREF="http://www.elwood.com/eclipse-info">[Eclipse Home Page]</A>

</BODY>
</HTML>
